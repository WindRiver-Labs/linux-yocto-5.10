// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright 2019-2020 NXP
 */

/dts-v1/;

#include <dt-bindings/usb/pd.h>
#include "imx8mm-evk.dtsi"

/ {
	model = "FSL i.MX8MM EVK board";
	compatible = "fsl,imx8mm-evk", "fsl,imx8mm";

	aliases {
		spi0 = &flexspi;
	};
};

&ddrc {
	operating-points-v2 = <&ddrc_opp_table>;

	ddrc_opp_table: opp-table {
		compatible = "operating-points-v2";

		opp-25M {
			opp-hz = /bits/ 64 <25000000>;
		};

		opp-100M {
			opp-hz = /bits/ 64 <100000000>;
		};

		opp-750M {
			opp-hz = /bits/ 64 <750000000>;
		};
	};
};

&flexspi {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_flexspi>;
	status = "okay";

	flash@0 {
		reg = <0>;
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "jedec,spi-nor";
		spi-max-frequency = <80000000>;
		spi-tx-bus-width = <4>;
		spi-rx-bus-width = <4>;
	};
};

&usdhc3 {
	assigned-clocks = <&clk IMX8MM_CLK_USDHC3_ROOT>;
	assigned-clock-rates = <400000000>;
	pinctrl-names = "default", "state_100mhz", "state_200mhz";
	pinctrl-0 = <&pinctrl_usdhc3>;
	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
	bus-width = <8>;
	non-removable;
	status = "okay";
};

&csi1_bridge {
        fsl,mipi-mode;
        status = "okay";
        port {
                csi1_ep: endpoint {
                        remote-endpoint = <&csi1_mipi_ep>;
                };
        };
};

&i2c3 {
        clock-frequency = <100000>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_i2c3>;
        status = "okay";

        pca6416: gpio@20 {
                compatible = "ti,tca6416";
                reg = <0x20>;
                gpio-controller;
                #gpio-cells = <2>;
                vcc-supply = <&buck4_reg>;
        };

        ak4458_1: ak4458@10 {
                compatible = "asahi-kasei,ak4458";
                reg = <0x10>;
                AVDD-supply = <&reg_audio_board>;
                DVDD-supply = <&reg_audio_board>;
        };

        ak4458_2: ak4458@12 {
                compatible = "asahi-kasei,ak4458";
                reg = <0x12>;
                AVDD-supply = <&reg_audio_board>;
                DVDD-supply = <&reg_audio_board>;
        };

        ak5558: ak5558@13 {
                compatible = "asahi-kasei,ak5558";
                reg = <0x13>;
                ak5558,pdn-gpio = <&pca6416 3 GPIO_ACTIVE_HIGH>;
                AVDD-supply = <&reg_audio_board>;
                DVDD-supply = <&reg_audio_board>;
        };

        ak4497: ak4497@11 {
                compatible = "asahi-kasei,ak4497";
                reg = <0x11>;
                ak4497,pdn-gpio = <&pca6416 5 GPIO_ACTIVE_HIGH>;
                AVDD-supply = <&reg_audio_board>;
                DVDD-supply = <&reg_audio_board>;
        };

	ov5640_mipi: ov5640_mipi@3c {
                compatible = "ovti,ov5640_mipi";
                reg = <0x3c>;
                status = "okay";
                pinctrl-names = "default";
                pinctrl-0 = <&pinctrl_csi_pwn>, <&pinctrl_csi_rst>;
                clocks = <&clk IMX8MM_CLK_CLKO1>;
                clock-names = "csi_mclk";
                assigned-clocks = <&clk IMX8MM_CLK_CLKO1>;
                assigned-clock-parents = <&clk IMX8MM_CLK_24M>;
                assigned-clock-rates = <24000000>;
                csi_id = <0>;
                pwn-gpios = <&gpio1 7 GPIO_ACTIVE_HIGH>;
                mclk = <24000000>;
                mclk_source = <0>;
                port {
                        ov5640_mipi1_ep: endpoint {
                                remote-endpoint = <&mipi1_sensor_ep>;
                        };
                };
        };
};

&iomuxc {
	pinctrl_csi_pwn: csi_pwn_grp {
                fsl,pins = <
                        MX8MM_IOMUXC_GPIO1_IO07_GPIO1_IO7               0x19
                >;
        };

        pinctrl_csi_rst: csi_rst_grp {
                fsl,pins = <
                        MX8MM_IOMUXC_GPIO1_IO06_GPIO1_IO6               0x19
                        MX8MM_IOMUXC_GPIO1_IO14_CCMSRCGPCMIX_CLKO1      0x59
                >;
        };

	pinctrl_flexspi: flexspigrp {
		fsl,pins = <
			MX8MM_IOMUXC_NAND_ALE_QSPI_A_SCLK               0x1c2
			MX8MM_IOMUXC_NAND_CE0_B_QSPI_A_SS0_B            0x82
			MX8MM_IOMUXC_NAND_DATA00_QSPI_A_DATA0           0x82
			MX8MM_IOMUXC_NAND_DATA01_QSPI_A_DATA1           0x82
			MX8MM_IOMUXC_NAND_DATA02_QSPI_A_DATA2           0x82
			MX8MM_IOMUXC_NAND_DATA03_QSPI_A_DATA3           0x82
		>;
	};

	pinctrl_i2c2: i2c2grp {
                fsl,pins = <
                        MX8MM_IOMUXC_I2C2_SCL_I2C2_SCL                  0x400001c3
                        MX8MM_IOMUXC_I2C2_SDA_I2C2_SDA                  0x400001c3
                >;
        };
	
	pinctrl_mipi_dsi_en: mipi_dsi_en {
                fsl,pins = <
                        MX8MM_IOMUXC_GPIO1_IO08_GPIO1_IO8               0x16
                >;
        };

	pinctrl_i2c2_synaptics_dsx_io: synaptics_dsx_iogrp {
                fsl,pins = <
                        MX8MM_IOMUXC_GPIO1_IO09_GPIO1_IO9               0x19    /* Touch int */
                >;
        };

	pinctrl_usdhc3: usdhc3grp {
		fsl,pins = <
			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK               0x190
			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD               0x1d0
			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0           0x1d0
			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1           0x1d0
			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2           0x1d0
			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2           0x1d0
			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3           0x1d0
			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4             0x1d0
			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5            0x1d0
			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6            0x1d0
			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7              0x1d0
			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE           0x190
		>;
	};

	pinctrl_usdhc3_100mhz: usdhc3-100mhzgrp {
		fsl,pins = <
			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK               0x194
			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD               0x1d4
			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0           0x1d4
			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1           0x1d4
			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2           0x1d4
			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3           0x1d4
			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4             0x1d4
			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5            0x1d4
			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6            0x1d4
			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7              0x1d4
			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE           0x194
		>;
	};

	pinctrl_usdhc3_200mhz: usdhc3-200mhzgrp {
		fsl,pins = <
			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK               0x196
			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD               0x1d6
			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0           0x1d6
			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1           0x1d6
			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2           0x1d6
			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3           0x1d6
			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4             0x1d6
			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5            0x1d6
			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6            0x1d6
			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7              0x1d6
			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE           0x196
		>;
	};
};

&i2c2 {
        clock-frequency = <400000>;
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_i2c2>;
        status = "okay";

        adv_bridge: adv7535@3d {
                compatible = "adi,adv7533";
                reg = <0x3d>;
                adi,addr-cec = <0x3b>;
                adi,dsi-lanes = <4>;
                pinctrl-names = "default";
                pinctrl-0 = <&pinctrl_i2c2_synaptics_dsx_io>;
                interrupt-parent = <&gpio1>;
                interrupts = <9 IRQ_TYPE_LEVEL_LOW>;
                status = "okay";

                port {
                        adv7535_from_dsim: endpoint {
                                remote-endpoint = <&dsim_to_adv7535>;
                        };
                };
        };

        ptn5110: tcpc@50 {
                compatible = "nxp,ptn5110";
                pinctrl-names = "default";
                pinctrl-0 = <&pinctrl_typec1>;
                reg = <0x50>;
                interrupt-parent = <&gpio2>;
                interrupts = <11 8>;
                status = "okay";

                port {
                        typec1_dr_sw: endpoint {
                                remote-endpoint = <&usb1_drd_sw>;
                        };
                };

                typec1_con: connector {
                        compatible = "usb-c-connector";
                        label = "USB-C";
                        power-role = "dual";
                        data-role = "dual";
                        try-power-role = "sink";
                        source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
                        sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
                                     PDO_VAR(5000, 20000, 3000)>;
                        op-sink-microwatt = <15000000>;
                        self-powered;
                };
        };
};

&lcdif {
	status = "okay";
};

&mipi_csi_1 {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	port {
		mipi1_sensor_ep: endpoint@1 {
			remote-endpoint = <&ov5640_mipi1_ep>;
			data-lanes = <2>;
			csis-hs-settle = <13>;
			csis-clk-settle = <2>;
			csis-wclk;
		};

		csi1_mipi_ep: endpoint@2 {
			remote-endpoint = <&csi1_ep>;
		};
	};
};

&mipi_dsi {
	status = "okay";

	port@1 {
		dsim_to_adv7535: endpoint {
			remote-endpoint = <&adv7535_from_dsim>;
		};
	};
};

&vpu_g1 {
	status = "okay";
};

&vpu_g2 {
	status = "okay";
};

&vpu_h1 {
	status = "okay";
};

&gpu {
	status = "okay";
};
